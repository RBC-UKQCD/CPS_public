/*
 * Please do not edit this file.
 * It was generated using PAB's VML system.
 */

#include <alg/qpropw_arg.h>
CPS_START_NAMESPACE

bool_t
vml_SourceType (VML *vmls, char *name,SourceType *objp)
{
	register int32_t *buf;

	if (!vml_enum (vmls,name,(enum_t *)objp,SourceType_map))
		return FALSE;
	return TRUE;
}
struct vml_enum_map SourceType_map[] = {
	{"SourceType","POINT",POINT},
	{"SourceType","VOLUME",VOLUME},
	{"SourceType","WALL",WALL},
	{"SourceType","BOX",BOX},
	{"SourceType","RANDVOLUME",RANDVOLUME},
	{"SourceType","RANDWALL",RANDWALL},
	{"SourceType","RANDSLAB",RANDSLAB},
	{"SourceType","MESSEQ",MESSEQ},
	{"SourceType","PROT_U_SEQ",PROT_U_SEQ},
	{"SourceType","PROT_D_SEQ",PROT_D_SEQ},
	{"SourceType","UNDEF",UNDEF},
	{"SourceType","DERIV",DERIV},
	{"SourceType","GAUSS_GAUGE_INV",GAUSS_GAUGE_INV},
	{"SourceType","EXP",EXP},
	{"SourceType","SUM_MOM",SUM_MOM},
	{"SourceType","FL_FUNC",FL_FUNC},
	{"SourceType","MOM",MOM},
	{NULL,NULL,0}
};

bool_t
vml_RandomType (VML *vmls, char *name,RandomType *objp)
{
	register int32_t *buf;

	if (!vml_enum (vmls,name,(enum_t *)objp,RandomType_map))
		return FALSE;
	return TRUE;
}
struct vml_enum_map RandomType_map[] = {
	{"RandomType","GAUSS",GAUSS},
	{"RandomType","UONE",UONE},
	{"RandomType","ZTWO",ZTWO},
	{"RandomType","NORAND",NORAND},
	{NULL,NULL,0}
};
	 bool QPropWArg::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool QPropWArg::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool QPropWArg::Vml(VML *vmls,char *instance){
		 if(!vml_QPropWArg(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_QPropWArg (VML *vmls, char *name,QPropWArg *objp)
{
	register int32_t *buf;

	 vml_class_begin(vmls,"QPropWArg",name);
	 if (!vml_CgArg (vmls, "cg", &objp->cg))
		 return FALSE;
	 if (!vml_string (vmls, "file", &objp->file, ~0))
		 return FALSE;
	 if (!vml_int (vmls, "x", &objp->x))
		 return FALSE;
	 if (!vml_int (vmls, "y", &objp->y))
		 return FALSE;
	 if (!vml_int (vmls, "z", &objp->z))
		 return FALSE;
	 if (!vml_int (vmls, "t", &objp->t))
		 return FALSE;
	 if (!vml_int (vmls, "gauge_fix_src", &objp->gauge_fix_src))
		 return FALSE;
	 if (!vml_int (vmls, "gauge_fix_snk", &objp->gauge_fix_snk))
		 return FALSE;
	 if (!vml_int (vmls, "store_midprop", &objp->store_midprop))
		 return FALSE;
	 if (!vml_int (vmls, "save_prop", &objp->save_prop))
		 return FALSE;
	 if (!vml_int (vmls, "do_half_fermion", &objp->do_half_fermion))
		 return FALSE;
	 vml_class_end(vmls,"QPropWArg",name);
	return TRUE;
}
	 bool QPropWGFArg::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool QPropWGFArg::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool QPropWGFArg::Vml(VML *vmls,char *instance){
		 if(!vml_QPropWGFArg(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_QPropWGFArg (VML *vmls, char *name,QPropWGFArg *objp)
{
	register int32_t *buf;

	 vml_class_begin(vmls,"QPropWGFArg",name);
	 if (!vml_int (vmls, "gauge_fix_src", &objp->gauge_fix_src))
		 return FALSE;
	 vml_class_end(vmls,"QPropWGFArg",name);
	return TRUE;
}
	 bool QPropWPointArg::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool QPropWPointArg::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool QPropWPointArg::Vml(VML *vmls,char *instance){
		 if(!vml_QPropWPointArg(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_QPropWPointArg (VML *vmls, char *name,QPropWPointArg *objp)
{
	register int32_t *buf;

	 vml_class_begin(vmls,"QPropWPointArg",name);
	 if (!vml_int (vmls, "x", &objp->x))
		 return FALSE;
	 if (!vml_int (vmls, "y", &objp->y))
		 return FALSE;
	 if (!vml_int (vmls, "z", &objp->z))
		 return FALSE;
	 vml_class_end(vmls,"QPropWPointArg",name);
	return TRUE;
}
	 bool QPropWBoxArg::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool QPropWBoxArg::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool QPropWBoxArg::Vml(VML *vmls,char *instance){
		 if(!vml_QPropWBoxArg(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_QPropWBoxArg (VML *vmls, char *name,QPropWBoxArg *objp)
{
	register int32_t *buf;

	 vml_class_begin(vmls,"QPropWBoxArg",name);
	 if (!vml_int (vmls, "box_start", &objp->box_start))
		 return FALSE;
	 if (!vml_int (vmls, "box_end", &objp->box_end))
		 return FALSE;
	 vml_class_end(vmls,"QPropWBoxArg",name);
	return TRUE;
}
	 bool QPropWRandArg::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool QPropWRandArg::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool QPropWRandArg::Vml(VML *vmls,char *instance){
		 if(!vml_QPropWRandArg(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_QPropWRandArg (VML *vmls, char *name,QPropWRandArg *objp)
{
	register int32_t *buf;

	 vml_class_begin(vmls,"QPropWRandArg",name);
	 if (!vml_RandomType (vmls, "rng", &objp->rng))
		 return FALSE;
	 if (!vml_int (vmls, "seed", &objp->seed))
		 return FALSE;
	 vml_class_end(vmls,"QPropWRandArg",name);
	return TRUE;
}
	 bool QPropWSlabArg::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool QPropWSlabArg::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool QPropWSlabArg::Vml(VML *vmls,char *instance){
		 if(!vml_QPropWSlabArg(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_QPropWSlabArg (VML *vmls, char *name,QPropWSlabArg *objp)
{
	register int32_t *buf;

	 vml_class_begin(vmls,"QPropWSlabArg",name);
	 if (!vml_QPropWRandArg (vmls, "rand_arg", &objp->rand_arg))
		 return FALSE;
	 if (!vml_int (vmls, "slab_width", &objp->slab_width))
		 return FALSE;
	 vml_class_end(vmls,"QPropWSlabArg",name);
	return TRUE;
}
	 bool QPropWExpArg::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool QPropWExpArg::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool QPropWExpArg::Vml(VML *vmls,char *instance){
		 if(!vml_QPropWExpArg(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_QPropWExpArg (VML *vmls, char *name,QPropWExpArg *objp)
{
	register int32_t *buf;

	 vml_class_begin(vmls,"QPropWExpArg",name);
	 if (!vml_Float (vmls, "exp_A", &objp->exp_A))
		 return FALSE;
	 if (!vml_Float (vmls, "exp_B", &objp->exp_B))
		 return FALSE;
	 if (!vml_Float (vmls, "exp_C", &objp->exp_C))
		 return FALSE;
	 vml_class_end(vmls,"QPropWExpArg",name);
	return TRUE;
}
CPS_END_NAMESPACE
